
注册bean到spring容器，bean实例化之前的准备工作
AnnotationConfigApplicationContext扫描指定包路径bean的过程
	1、包路径转换成绝对路径 classpath*:com/cn/allen/entity/**/*.class
	2、递归查找路径下的所有class文件（FileSystem文件系统）findCandidateComponents方法最终会递归查找路径下的所有class文件
	3、遍历class文件，包装成SimpleMetadataReader（通过字节流的方式读取class文件）
	4、判断类上面是否有@Component注解（所有的注解都有@Component），如果有，封装成BeanDefinition放入Set容器，否则不做任何处理；
	如果打开debug模式的话，会提示用户这个类被忽视了，也就是说它的生命周期不交给spring管理
	5、遍历Set容器中的BeanDefinition，设置bean基本属性值，包括作用域、是否懒加载、自动注入类型、依赖检查等
	6、检测bean是否beanDefinitionMap容器中，如果不存在，则把BeanDefinition包装成BeanDefinitionHolder，注册到beanDefinitionMap容器





需要重点关注的接口
Advisor

Aware
    为了使用spring的功能
FactoryBean
	自己实现的FactoryBean
	表示不会急于初始化这个bean（Desk），即使它是单例的
	只有实际调用getObject方法才会进行初始化
	总结：自己实现的FactoryBean<T> 中T对象的初始化动作不是spring来做，而是由开发人员处理。
	这个接口在框架中被大量使用，例如aop，ProxyFactoryBean

	为什么实现了FactoryBean的类不会执行getBean？
      如果一个bean实现了这个接口，它就会被当成一个对象工厂来使用，而不是普通的bean实例，它的生命周期不归spring管，
      调用getObject方法始终返回的是它创建的对象引用。
BeanFactoryAware
	bean生命周期接口，实现BeanFactoryAware接口可以获取其他的Bean信息，即一个bean可以通过实现BeanFactoryAware接口（beanFactory）查找协作bean（依赖查找）；可以认为这是获取依赖的bean的一种方式，但大多数bean会选择通过相应的bean属性或有参的构造函数获取bean的引用（依赖注入）
BeanFactory
	访问spring bean容器的顶层接口，里面有bean的生命周期方法


问题点
lite（CONFIGURATION_CLASS_LITE）、full（CONFIGURATION_CLASS_FULL）代表的是什么
什么是ASM


解析配置类
ConfigurationClassParser(在invokeBeanFactoryPostProcessors()方法注册)
	处理配置类以及它的超类，包括@Component、@PropertySource、@ComponentScan、@Import、@ImportResource、@Bean注解
	->doProcessConfigurationClass

先 @Componet 然后是 @PropertySources @ComponentScans @Import @Bean

post-processor在spring中的应用
	ConfigurationClassPostProcessor



bean的实例化过程
	1、遍历注册bean的容器beanDefinitionNames，并判断是否是抽象类、是否懒加载、是否单例
	2、判断是否实现FactoryBean接口，如果实现此接口，则该对象为对象工厂，不是普通bean实例，不会执行getBean方法；否则，执行getBean -> doGetBean
	3、拿到规范的beanName到三级缓存中去找，第一次会返回null，三级缓存里面还没有对应的值
	4、判断是否单例，调用createBean创建单例bean -> doCreateBean
	5、寻找有@Autowired注解的构造参数
		5.1、遍历bean的所有方法，检查是否有@Lookup注解，有的话，把方法method和注解的value值包装成LookupOverride，添加到MethodOverrides的Set容器中
		5.2、双重检查candidateConstructorsCache容器中有没有，反射获取bean声明的所有构造函数
		5.3、遍历所有构造函数，查找有@Autowired注解的构造函数，并封装成AnnotationAttributes存放到ArrayList容器
		5.4、返回一个有@Autowired注解的构造函数数组
    6、如果找到有@Autowired注解的构造函数，则调用autowireConstructor方法解析有@Autowired注解的构造方法
    (至少有一个符合Autowired候选条件的bean，即至少要有一个@Autowired注解的构造函数上有bean的引用，并且不能有基本数据类型)
        6.1、参数解析（涉及循环依赖——三级缓存），反射实例化构造函数
	7、否则，没有@Autowired注解或有多个构造函数并且没有此注解的情况下，调用instantiateBean无参构造函数实例化，封装成BeanWrapper
	（只有一个有参构造函数并且没有注解的情况下会被缓存到candidateConstructorsCache构造函数容器中，当成有注解来处理）
	8、调用applyMergedBeanDefinitionPostProcessors方法进行对象属性的注入，执行一系列的BeanPostProcessor
		8.1、收集该类以及父类的init、destroy方法，封装成LifecycleMetadata
		8.2、收集该类以及父类中带有注解的字段（@WebServiceRef、@EJB、@Resource）或者setter方法的注入信息，封装成InjectionMetadata
		8.3、收集收集该类以及父类中带有@Autowired注解的字段和方法，封装成InjectionMetadata
	9、判断bean是否允许提前暴露，如果允许，把它添加到三级缓存，从二级缓存移除
	10、执行populateBean方法，进行ioc依赖注入
	    10.1、调用一系列的postProcessProperties方法，收集有该类以及父类中带有@Autowired注解和公共注解（@WebServiceRef、@EJB、@Resource）的字段和方法，
	    封装成InjectionMetadata对象，调用inject方法实现字段赋值（最终会调到getBean方法，获取实例对象）以及方法的调用，完成ioc注入
	11、执行initializeBean方法，完成bean实例化，以及实例化是否采用代理aop的操作等
	    11.1、initializeBean -> applyBeanPostProcessorsBeforeInitialization
	    调用一系列初始化之前的处理器postProcessBeforeInitialization，包括执行Aware接口、init方法、afterPropertiesSet方法等
	    11.2、调用一系列初始化之后的处理器postProcessAfterInitialization，返回bean实例（代理实例）
	12、销毁bean，ContextLoaderListener -> contextDestroyed 销毁bean由Web容器去做，例如Tomcat

aop流程（aop代理在bean完成实例化之后进行;如果有@Aspect注解，则返回的是代理实例;aop入口AbstractAutowiredCapableBeanFactory->postProcessAfterInitialization）
    1、加上@EnableAspectJAutoProxy开启aop
    2、执行AbstractAutoProxyCreator -> getAdvicesAndAdvisorsForBean得到所有的切面
        2.1、程序启动时，扫描所有的bean实例，遍历判断bean上是否有@Aspect注解（beanFactory是DefaultListableBeanFactory）
        2.2、如果有，调用ReflectiveAspectJAdvisorFactory -> getAdvisors 收集该bean上的所有Advisor
        2.3、拿到切面类和切面名称，获取该类的除了@PointCut注解以外的所有增强方法
        2.4、遍历所有增强方法，根据增强方法上的切点方法获取到对应的表达式，封装成AspectJExpressionPointCut对象
        2.5、切点表达式不为null的情况下，把增强方法和对应的切点表达式封装成Advisor（InstantiationModelAwarePointcutAdvisorImpl），保存到ArrayList容器中返回
    3、执行AbstractAutoProxyCreator -> createProxy，创建代理
        3.1、首先创建代理工厂，调用buildAdvisors方法构建指定的以及公共的切面类
        3.2、通过代理工厂getProxy方法创建代理，选择是jdk动态代理，还是cglib动态代理
        3.3、如果是jdk动态代理，获取代理接口，查找代理接口中定义的equals和hashCode方法，使用反射创建代理实例并返回；
        如果是cglib动态代理，创建Enhancer（增强类，即代理类）对象实例，配置代理类
        3.4、使用反射创建代理实例，并返回
    4、调用tranService.search()会执行到JdkDynamicAopProxy的invoke方法，通过MyService的代理对象调用实际的方法
        4.1、拿到这个方法的拦截器链
            4.1.1、获取所有的切面，遍历切面，如果PointcutAdvisor，判断目标类跟切点表达式是否匹配
            4.1.2、如果匹配的话，拿到切点表达式对应的advice，遍历由MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter
            组成的增强适配器容器，如果类型匹配的话，则将advice包装成对应的拦截器保存到拦截器容器中
            4.1.3、如果是其他的拦截器（CacheInterceptor、AspectJAroundAdviceInterceptor等，继承了MethodInterceptor接口），则添加到拦截拦截器容器
        4.2、返回拦截器链
    #5、把被调用的method方法封装成MethodCacheKey作为key，拦截器链作为value，保存到methodCache容器（缓存）
    6、创建方法调用对象ReflectiveMethodInvocation，执行proceed方法（链式调用的拦截器上的invoke方法）
    7、最后执行目标方法，完成整个的执行流程

    五种增强：Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class

事务执行流程
    1、spring事务采用aop的方式实现的（事务对象指的就是DataSourceTransactionObject，在TransactionInterceptor完成调用）
    2、TransactionAspectSupport -> invokeWithinTransaction() 调用createTransactionIfNecessary方法创建事务
        2.0、调用doGetTransaction方法获取事务对象DataSourceTransactionObject
            2.0.1、如果存在事务，调用AbstractPlatformTransactionManager -> handleExistingTransaction()方法为现有事务创建事务状态
            2.0.2、根据相应的事务传播特性做相应的处理，如果是PROPAGATION_REQUIRES_NEW，会调用suspend() -> doSuspend()方法将当前事务挂起，
            把事务对象中的连接对象设置为null，解除数据源和连接对象的绑定关系
            2.0.3、默认新启一个事务
        2.1、第一次调用会新建一个事务状态newTransactionStatus，默认事务传播特性是PROPAGATION_REQUIRED（如果没有事务，则新建；若已存在事务，则加入到此事务）
        2.2、DataSourceTransactionManager -> doBegin()开启事务
            2.2.1、从连接池中获取连接，并将连接包装成ConnectionHolder对象
            2.2.2、关闭自动提交，调用prepareTransactionalConnection()方法如果事务设置为只读的话，会执行"SET TRANSACTION READ ONLY"语句，说明这是只读事务
            2.2.3、如果是新建的连接，会把数据源dataSource（key）和连接对象connectionHolder（value）绑定到ThreadLocal中（ThreadLocal<Map<Object, Object>>）
        2.3、调用prepareSynchronization()方法，设置实际事务状态、隔离级别、当前事务是否只读、事务名称等，返回事务状态，根据需要初始化事务同步
        2.4、返回事务状态TransactionStatus
    3、TransactionAspectSupport -> prepareTransactionInfo 根据给定的属性和状态对象准备TransactionInfo，把TransactionInfo绑定到当前线程（存储在ThreadLocal<TransactionInfo>）
    4、执行环绕增强 invocation.proceedWithInvocation()，执行目标方法
    5、TransactionAspectSupport -> commitTransactionAfterReturning 提交事务
        5.1、执行AbstractPlatformTransactionManager -> commit 方法，如果本地需要回滚，则调用processRollback方法进行回滚；否则调用processCommit处理实际的提交
            5.1.1、那么调用processCommit方法，如果有回滚点，要清除回滚点；如果是新建事务，执行doCommit方法，拿到数据库连接，执行真正的commit方法完成提交操作
                5.1.1.1、执行AbstractPlatformTransactionManager -> cleanupAfterCompletion方法，清除当前线程的事务同步状态
                5.1.1.2、如果是新建事务，调用DataSourceTransactionManager -> doCleanupAfterCompletion方法释放资源，
                TransactionSynchronizationManager.unbindResource -> doUnbindResource 将数据源DataSource和连接对象ConnectionHolder解除绑定关系，返回连接对象
                5.1.1.3、重置连接，包括恢复连接的自动提交、默认隔离级别以及是否只读等属性
                5.1.1.4、调用DataSourceUtils -> releaseConnection -> doReleaseConnection方法释放连接，最终会调用close方法关闭连接
                5.1.1.5、修改事务活动状态，清除保存点
                5.1.1.6、如果有挂起的连接（资源），调用resume(transaction,suspendedResourceHolder) -> doResume() 方法恢复数据源和连接的绑定关系
                5.1.1.7、重新恢复事务状态、隔离级别、事务名称、是否只读等属性；重新激活当前线程的事务同步
             5.1.2、如果出现异常，将调用TransactionAspectSupport -> completeTransactionAfterThrowing方法处理
                5.1.2.1、执行AbstractPlatformTransactionManager -> rollback -> processRollback 方法进行事务回滚
                5.1.2.2、执行TransactionSynchronizationUtils -> triggerBeforeCompletion方法，SqlSessionUtils -> beforeCompletion方法，调到unbindResource，解除数据源和连接对象的绑定关系
                5.1.2.3、如果是新建事务，调用doRollback()获取连接对象Connection，调用数据库连接对象的回滚方法进行回滚
                    5.1.2.3.1、执行5.1.1.x（x表示1，2，3，4，5） 的处理逻辑释放资源
                    5.1.2.3.2、抛出异常
                5.1.2.4、如果有保存点（回滚点），即出异常的事务是嵌套事务，执行AbstractTransactionStatus -> rollbackToHeldSavepoint()方法回滚到指定的保存点
                    5.1.2.4.1、调用getSavepoint()方法获取保存点，执行JdbcTransactionObjectSupport -> rollbackToSavepoint()方法，
                    最终执行数据库连接的rollback()方法回滚到指定的保存点
                    5.1.2.4.2、调用releaseSavepoint()方法释放保存，并设置事务状态对象的保存点为null；总结：调用rollbackToSavepoint回滚之后，执行releaseSavepoint释放保存点
                5.1.2.5、执行5.1.1.x（x表示1，2，3，4，5） 的处理逻辑释放资源


事务的挂起调用suspend(transaction)方法就是将当前事务对象的属性值设置为默认，事务名称、事务隔离级别、连接对象置为null，并封装成SuspendedResourcesHolder对象

事务隔离级别
    PROPAGATION_REQUIRES_NEW：如果存在外层事务，则将事务挂起，新建一个事务
        如果存在事务，那么将调用suspend(transaction)挂起事务，连接对象置为null，解除数据源和连接的绑定关系，返回旧连接对象包装成SuspendedResourcesHolder对象。
     使用旧连接对象重新创建事务状态，返回新的事务
    PROPAGATION_REQUIRED：如果不存在外层事务，则新建事务；存在，则使用当前事务
    PROPAGATION_SUPPORTS：支持当前事务，如果不存在事务，则已非事务方式执行
    #SUPPORTS和REQUIRED的共同点都是如果存在事务，就使用当前事务
    PROPAGATION_MANDATORY：支持当前事务，如果不存在事务，则抛出异常
    PROPAGATION_NOT_SUPPORTED：不支持事务，如果存在事务，则挂起
    PROPAGATION_NEVER：不使用事务，如果存在事务，则抛出异常
    PROPAGATION_NESTED：如果存在事务，则在嵌套事务内执行设置保存点；如果不存在事务，则新建事务，执行与PROPAGATION_REQUIRED类似的操作
        如果存在事务，使用当前事务创建一个新的事务状态，并设置保存点


springMvc调用流程（SpringServletContainerInitializer，spi的思想）
    1、SpringServletContainerInitializer会在启动时被servlet容器实例化，并调用onStartup()方法，而且servlet容器
    收集实现了@HandlesTypes注解里面的接口的类，并且作为入参传入onStartup方法中，通过获取set容器中类就可以反射调用接口里面的方法，
    这就是servlet规范
    2、调用onStartup方法完成spring容器和mvc容器的注册
        2.1、执行registerContextLoaderListener()方法，完成上下文监听器的注册
            2.1.1、调用createRootApplicationContext方法创建Web应用程序上下文对象AnnotationConfigWebApplicationContext（root，父容器），
            注册spring容器配置类到注解容器annotatedClasses中
            2.1.2、创建上下文监听器ContextLoaderListener监听Web应用程序上下文对象
            2.1.3、注册上下文监听器到servlet容器
        2.2、执行registerDispatcherServlet()方法，注册DispatcherServlet
            2.2.1、调用createServletApplicationContext方法创建Web应用程序上下文对象AnnotationConfigWebApplicationContext（sub，子容器），
            注册mvc容器配置类到注解容器annotatedClasses（LinkedHashSet）中
            2.2.2、执行createDispatcherServlet方法创建DispatcherServlet对象，注册servlet、设置启动顺序、添加映射url、设置是否异步处理，
            如果有过滤器的话，注册过滤器
            2.2.3、调用customizeRegistration方法可以在registerDispatcherServlet()执行完成后执行进一步的定制
    3、执行ContextLoaderListener -> contextInitialized() 方法初始化web应用程序上下文
        3.1、执行loadParentContext方法加载父容器，并设置当前上下文
        3.2、调用 ContextLoader -> configureAndRefreshWebApplicationContext方法配置和刷新Web应用程序上下文
        3.3、设置ConfigurableWebApplicationContext对象属性值，包括上下文id、servlet上下文、配置文件路径
        3.4、调用customizeContext()方法自定义上下文，执行determineContextInitializerClasses()收集声明的上下文初始化类，
        如果有，遍历解析参数类，排序，执行initialize方法完成初始化
        3.5、执行AbstractApplicationContext -> refresh方法，加载或刷新配置，可以是xml文件、属性文件或者关系数据库，这是一个启动
        方法，如果失败，它应该销毁已经创建的单例，以避免资源的挂起。换句话说，调用这个方法之后，要么全部实例化，要么都不实例化。即开始bean的实例化
        流程
        3.6、完成Spring容器（Spring容器）的启动
    4、SpringMvc的入口类是DispatcherServlet，调用到HttpServletBean -> init()方法将配置参数映射到这个servlet的bean属性上，并且
    调用子类的初始化方法FrameworkServlet -> initServletBean()，执行initWebApplicationContext()进行web应用程序上下文初始化工作
        4.1、调用WebApplicationContextUtils.getWebApplicationContext()方法在servletContext中获取ContextLoaderListener监听的容器
        4.2、调用setParent方法，将容器设置到上下文对象中。所以由监听器启动的容器（SpringContainer）是父容器，DispatcherServlet启动的
        容器（MvcContainer）是子容器，两者是父子关系
     5、最终会执行到refresh()方法完成DispatcherServlet容器（Mvc容器）的启动
     6、SpringMvc核心类WebMvcConfigurationSupport，完成组件的实例化
        6.1、例如：WebMvcConfigurationSupport -> requestMappingHandlerMapping()方法收集请求路径的映射，以及获取拦截器、跨域的配置等
            6.1.1、调用createRequestMappingHandlerMapping方法创建RequestMappingHandlerMapping对象，
            先执行父类AbstractHandlerMethodMapping -> afterPropertiesSet() -> initHandlerMethods()方法，扫描上下文中的所有bean
            6.1.2、遍历所有的bean，调用processCandidateBean(beanName)方法确定指定的候选bean类型
            6.1.3、判断该bean是否有@Controller或@RequestMapping注解，如果有（被标识为处理程序类型），则调用detectHandlerMethods(beanName)方法，
            在指定的处理bean中查找处理方法
            6.1.4、执行ClassUtils -> getUserClass(clazz)方法，如果是代理类，则获取它的目标类并返回，否则直接返回当前类
            6.1.5、调用selectMethods方法内部递归查找该类以及父类的@RequestMapping注解，获取注解上的参数包装成RequestMappingInfo对象
            6.1.6、将类（common）和方法（index）上的@RequestMapping的value参数值合并（例如：common/index），重新创建一个新的RequestMappingInfo对象保存
            6.1.7、遍历得到methods，调用AbstractHandlerMethodMapping -> registerHandlerMethod() -> register方法注册到mappingRegistry容器中（MappingRegistry）
            6.1.8、调用createHandlerMethod()方法把method和对应的handler（bean实例）创建一个HandlerMethod对象进行保存，放入mappingLookup（Map<T, HandlerMethod>，这里T是RequestMappingInfo）容器中
            6.1.9、根据名称的策略使用处理方法handlerMethod和映射的路径mapping提取名称，例如CommonController.success()，提取的名称是CC#success，
            加入nameLookup（Map<String, List<HandlerMethod>>）容器
            6.1.10、调用initCorsConfiguration()初始化跨域配置信息
                6.1.10.1、执行createHandlerMethod方法创建HandlerMethod对象
                6.1.10.2、收集类以及方法上的@CrossOrigin的注解，执行updateCorsConfig方法添加请求来源，http方法，以及其他的请求头
                6.1.10.3、执行applyPermitDefaultValues方法应用cors的默认值
            6.1.11、添加映射和处理程序到注册表registry容器
     7、SpringMvc的执行过程，http请求会先执行HttpServlet -> service方法，根据请求方式调用对应的do*方法
        7.0、执行DispatcherServlet -> processRequest -> doService方法将DispatcherServlet的请求属性和委托公开给doDispatcher进行实际的调度
            7.0.1、执行到DispatcherServlet -> doDispatcher方法，主核心方法
        7.1、调用getHandler方法，确定当前请求的处理程序，最终调用getHandlerInternal方法，先获取查找的路径lookupPath：/common/success，
        执行AbstractHandlerMethodMapping -> lookupHandlerMethod方法为当前请求寻找最佳匹配的处理程序，封装成HandlerMethod对象返回
        7.2、执行AbstractHandlerMapping -> getHandlerExecutionChain(handlerMethod,request)方法当前处理程序的执行链，并返回
        7.3、执行DispatcherServlet -> getHandlerAdapter方法获取处理器适配器
        7.4、执行真正的处理器AbstractHandlerMethodAdapter -> handle -> handleInternal()方法，调用处理程序方法invokeHandlerMethod
        进行数据绑定，model初始化
        7.5、调用ServletInvocationHandlerMethod -> invokeForRequest方法，最终调用到doInvoke()方法通过动态代理执行目标方法，得到视图名称
        7.6、执行handlerReturnValue方法处理返回值，并且给ModelAndViewContainer对象设置视图名称
        7.7、执行RequestMappingHandlerAdapter -> getModelAndView()方法获取ModelAndView模型视图对象
        7.8、调用HandlerExecutionChain -> applyPostHandle方法执行注册的拦截器postHandle方法
        7.9、调用DispatcherServlet -> processDispatcherResult方法处理处理程序选择和处理程序调用的结果，可以是ModelAndView或者Exception
        7.10、执行DispatcherServlet -> render -> resolveViewName方法进行视图解析拿到视图对象View
        7.11、执行AbstractView -> render()方法准备给定指定模型的视图，与静态属性和RequestContext属性进行合并
        7.12、调用AbstractView -> prepareResponse方法准备响应头
        7.13、调用InternalResourceView -> renderMergedOutputModel方法渲染指定模型的内部资源，包括将模型设置为请求属性
        7.14、执行ApplicationDispatcher -> forward -> doForward()方法将此请求和响应转发给另一个资源去处理，请求完成
        7.15、资源的释放

SpringMvc的执行过程：访问url（..../common/success）先执行ApplicationFilterChain -> doFilter()过滤器方法，再执行到
HttpServlet -> service方法

SpringMvc核心类WebMvcConfigurationSupport，完成很多组件的实例化，包括HandlerMapping、HandlerAdapter、视图解析器viewResolver、异常处理器exceptionResolver，
并且提供了很多钩子方法，比如添加拦截器、添加跨域映射、配置异常处理器等方法


主流的spring Web组件DispatcherServlet、FrameworkServlet、ContextLoaderListener、DelegatingFilterProxy都支持构造参数注入

实现WebApplicationInitializer接口，使用编程的方式代替web.xml
 * public class MyWebAppInitializer implements WebApplicationInitializer {
 *
 *    &#064;Override
 *    public void onStartup(ServletContext container) {
 *      XmlWebApplicationContext appContext = new XmlWebApplicationContext();
 *      appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
 *
 *      ServletRegistration.Dynamic dispatcher =
 *        container.addServlet("dispatcher", new DispatcherServlet(appContext));
 *      dispatcher.setLoadOnStartup(1);
 *      dispatcher.addMapping("/");
 *    }
 *
 * }

还可以使用Spring的AnnotationConfigWebApplicationContext对代码进行重构，用@Configuration定义的
AppConfig和DispatcherConfig类来代替Spring的xml文件
示例：使用编程的方式注册ContextLoaderListener上下文监听器和DispatcherServlet容器
 * public class MyWebAppInitializer implements WebApplicationInitializer {
 *
 *    &#064;Override
 *    public void onStartup(ServletContext container) {
 *      // Create the 'root' Spring application context
 *      AnnotationConfigWebApplicationContext rootContext =
 *        new AnnotationConfigWebApplicationContext();
 *      rootContext.register(AppConfig.class);
 *
 *      // Manage the lifecycle of the root application context
 *      container.addListener(new ContextLoaderListener(rootContext));
 *
 *      // Create the dispatcher servlet's Spring application context
 *      AnnotationConfigWebApplicationContext dispatcherContext =
 *        new AnnotationConfigWebApplicationContext();
 *      dispatcherContext.register(DispatcherConfig.class);
 *
 *      // Register and map the dispatcher servlet
 *      ServletRegistration.Dynamic dispatcher =
 *        container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
 *      dispatcher.setLoadOnStartup(1);
 *      dispatcher.addMapping("/");
 *    }
 *
 * }
实现WebApplicationInitializer都是自动检测的






设计模式
    适配器模式
    委托模式
    模板方法模式
    门面模式：Tomcat启动servlet容器
    建造者模式：解析@RequestMapping注解参数封装成RequestMappingInfo对象



问题：
    1、如何在系统启动时加载某配置文件，加载不成功不启动服务？
        继承StandardEnvironment类，重写customizePropertySources()方法，把读取配置资源PropertySources放入
    MutablePropertySources容器中，可以实现在调用onRefresh()方法之前完成资源加载

