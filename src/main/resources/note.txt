
注册bean到spring容器，bean实例化之前的准备工作
AnnotationConfigApplicationContext扫描指定包路径bean的过程
	1、包路径转换成绝对路径 classpath*:com/cn/allen/entity/**/*.class
	2、递归查找路径下的所有class文件（FileSystem文件系统）findCandidateComponents方法最终会递归查找路径下的所有class文件
	3、遍历class文件，包装成SimpleMetadataReader（通过字节流的方式读取class文件）
	4、判断类上面是否有@Component注解（所有的注解都有@Component），如果有，封装成BeanDefinition放入Set容器，否则不做任何处理；
	如果打开debug模式的话，会提示用户这个类被忽视了，也就是说它的生命周期不交给spring管理
	5、遍历Set容器中的BeanDefinition，设置bean基本属性值，包括作用域、是否懒加载、自动注入类型、依赖检查等
	6、检测bean是否beanDefinitionMap容器中，如果不存在，则把BeanDefinition包装成BeandDefinitionHolder，注册到beanDefinitionMap容器





需要重点关注的接口
Advisor

Aware
    为了使用spring的功能
FactoryBean
	自己实现的FactoryBean
	表示不会急于初始化这个bean（Desk），即使它是单例的
	只有实际调用getObject方法才会进行初始化
	总结：自己实现的FactoryBean<T> 中T对象的初始化动作不是spring来做，而是由开发人员处理。
	这个接口在框架中被大量使用，例如aop，ProxyFactoryBean

	为什么实现了FactoryBean的类不会执行getBean？
      如果一个bean实现了这个接口，它就会被当成一个对象工厂来使用，而不是普通的bean实例，它的生命周期不归spring管，
      调用getObject方法始终返回的是它创建的对象引用。
BeanFactoryAware
	bean生命周期接口，实现BeanFactoryAware接口可以获取其他的Bean信息，即一个bean可以通过实现BeanFactoryAware接口（beanFactory）查找协作bean（依赖查找）；可以认为这是获取依赖的bean的一种方式，但大多数bean会选择通过相应的bean属性或有参的构造函数获取bean的引用（依赖注入）
BeanFactory
	访问spring bean容器的顶层接口，里面有bean的生命周期方法


问题点
lite（CONFIGURATION_CLASS_LITE）、full（CONFIGURATION_CLASS_FULL）代表的是什么
什么是ASM


解析配置类
ConfigurationClassParser(在invokeBeanFactoryPostProcessors()方法注册)
	处理配置类以及它的超类，包括@Component、@PropertySource、@ComponentScan、@Import、@ImportResource、@Bean注解
	->doProcessConfigurationClass

post-processor在spring中的应用
	ConfigurationClassPostProcessor



bean的实例化过程
	1、遍历注册bean的容器beanDefinitionNames，并判断是否是抽象类、是否懒加载、是否单例
	2、判断是否实现FactoryBean接口，如果实现此接口，则该对象为对象工厂，不是普通bean实例，不会执行getBean方法；否则，执行getBean -> doGetBean
	3、拿到规范的beanName到三级缓存中去找，第一次会返回null，三级缓存里面还没有对应的值
	4、判断是否单例，调用createBean创建单例bean -> doCreateBean
	5、寻找有@Autowired注解的构造参数
		5.1、遍历bean的所有方法，检查是否有@Lookup注解，有的话，把方法method和注解的value值包装成LookupOverride，添加到MethodOverrides的Set容器中
		5.2、双重检查candidateConstructorsCache容器中有没有，反射获取bean声明的所有构造函数
		5.3、遍历所有构造函数，查找有@Autowired注解的构造函数，并封装成AnnotationAttributes存放到ArrayList容器
		5.4、返回一个有@Autowired注解的构造函数数组
    6、如果找到有@Autowired注解的构造函数，则调用autowireConstructor方法解析有@Autowired注解的构造方法
    (至少有一个符合Autowired候选条件的bean，即至少要有一个@Autowired注解的构造函数上有bean的引用，并且不能有基本数据类型)
        6.1、参数解析（涉及循环依赖——三级缓存），反射实例化构造函数
	7、否则，没有@Autowired注解或有多个构造函数并且没有此注解的情况下，调用instantiateBean无参构造函数实例化，封装成BeanWrapper
	（只有一个有参构造函数并且没有注解的情况下会被缓存到candidateConstructorsCache构造函数容器中，当成有注解来处理）
	8、调用applyMergedBeanDefinitionPostProcessors方法进行对象属性的注入，执行一系列的BeanPostProcessor
		8.1、收集该类以及父类的init、destroy方法，封装成LifecycleMetadata
		8.2、收集该类以及父类中带有注解的字段（@WebServiceRef、@EJB、@Resource）或者setter方法的注入信息，封装成InjectionMetadata
		8.3、收集收集该类以及父类中带有@Autowired注解的字段和方法，封装成InjectionMetadata
	9、判断bean是否允许提前暴露，如果允许，把它添加到三级缓存，从二级缓存移除
	10、执行populateBean方法，进行ioc依赖注入
	    10.1、调用一系列的postProcessProperties方法，收集有该类以及父类中带有@Autowired注解和公共注解（@WebServiceRef、@EJB、@Resource）的字段和方法，
	    封装成InjectionMetadata对象，调用inject方法实现字段赋值（最终会调到getBean方法，获取实例对象）以及方法的调用，完成ioc注入
	11、执行initializeBean方法，完成bean实例化，以及实例化是否采用代理aop的操作等
	    11.1、initializeBean -> applyBeanPostProcessorsBeforeInitialization
	    调用一系列初始化之前的处理器postProcessBeforeInitialization，包括执行Aware接口、init方法、afterPropertiesSet方法等
	    11.2、调用一系列初始化之后的处理器postProcessAfterInitialization，返回bean实例（代理实例）
	12、销毁bean，ContextLoaderListener -> contextDestroyed 销毁bean由Web容器去做，例如Tomcat

aop流程（aop代理在bean完成实例化之后进行;如果有@Aspect注解，则返回的是代理实例）
    1、加上@EnableAspectJAutoProxy开启aop
    2、执行AbstractAutoProxyCreator -> getAdvicesAndAdvisorsForBean得到所有的切面
        2.1、程序启动时，扫描所有的bean实例，遍历判断bean上是否有@Aspect注解（beanFactory是DefaultListableBeanFactory）
        2.2、如果有，调用ReflectiveAspectJAdvisorFactory -> getAdvisors 收集该bean上的所有Advisor
        2.3、拿到切面类和切面名称，获取该类的除了@PointCut注解以外的所有增强方法
        2.4、遍历所有增强方法，根据增强方法上的切点方法获取到对应的表达式，封装成AspectJExpressionPointCut对象
        2.5、切点表达式不为null的情况下，把增强方法和对应的切点表达式封装成Advisor（InstantiationModelAwarePointcutAdvisorImpl），保存到ArrayList容器中返回
    3、执行AbstractAutoProxyCreator -> createProxy，创建代理
        3.1、首先创建代理工厂，调用buildAdvisors方法构建指定的以及公共的切面类
        3.2、通过代理工厂getProxy方法创建代理，选择是jdk动态代理，还是cglib动态代理
        3.3、如果是jdk动态代理，获取代理接口，查找代理接口中定义的equals和hashCode方法，使用反射创建代理实例并返回；
        如果是cglib动态代理，创建Enhancer（增强类，即代理类）对象实例，配置代理类
        3.4、使用反射创建代理实例，并返回
    4、调用tranService.search()会执行到JdkDynamicAopProxy的invoke方法，通过MyService的代理对象调用实际的方法
        4.1、拿到这个方法的拦截器链
            4.1.1、获取所有的切面，遍历切面，如果PointcutAdvisor，判断目标类跟切点表达式是否匹配
            4.1.2、如果匹配的话，拿到切点表达式对应的advice，遍历由MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter
            组成的增强适配器容器，如果类型匹配的话，则将advice包装成对应的拦截器保存到拦截器容器中
            4.1.3、如果是其他的拦截器（CacheInterceptor、AspectJAroundAdviceInterceptor等），则添加到拦截拦截器容器
        4.2、返回拦截器链
    #5、把被调用的method方法封装成MethodCacheKey作为key，拦截器链作为value，保存到methodCache容器（缓存）
    6、创建方法调用对象ReflectiveMethodInvocation，执行proceed方法（链式调用的拦截器上的invoke方法）
    7、最后执行目标方法

    五种增强：Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class

事务执行流程
    1、spring事务采用aop的方式实现的（事务对象指的就是DataSourceTransactionObject）
    2、调用createTransactionIfNecessary方法创建事务
        2.1、第一次调用会新建一个事务状态newTransactionStatus
        2.2、DataSourceTransactionManager -> doBegin()开启事务
            2.2.1、从连接池中获取连接，并将连接包装成ConnectionHolder对象
            2.2.2、关闭自动提交，如果事务设置为只读的话，会执行"SET TRANSACTION READ ONLY"语句，说明这是只读事务
            2.2.3、如果是新建的连接，会把数据源dataSource（key）和连接对象connectionHolder（value）绑定到ThreadLocal中（ThreadLocal<Map<Object, Object>>）
        2.3、初始化事务同步prepareSynchronization，设置实际事务状态、隔离级别、当前事务是否只读、事务名称等，返回事务状态


设计模式
    适配器模式
    委托模式
    模板方法模式











问题：


